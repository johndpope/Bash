Ця вправа є дуже важливою тому, що потоки, канали і списки команд використовуються всюди. Ви могли зустріти ці дивні `>` та `|` символи майже в будь–якому скрипті. Отже, давайте відкриємо секрет, що ж це насправді таке.

### Потоки

Bash отримує вхідні дані і посилає вивід у вигляді послідовностей або **потоків** символів. Ці потоки можуть бути перенаправлені в файли або з одного скрипту в інший.

Є три дескриптора:

| Код  | Дескриптор | Опис                 |
| :--: | :--------: | :------------------- |
| `0`  | `stdin`    | Стандартний вхід.    |
| `1`  | `stdout`   | Стандартний вихід.   |
| `2`  | `stderr`   | Вихід для помилок.   |

Перенаправлення дозволяє контролювати, і куди вивід команди йде, і звідки вхідні данні приходять. Для перенаправлення потоків використовуються ці оператори:

| Оператор | Опис                                         |
| :------: | :------------------------------------------- |
| `>`      | Перенапляє вихід                             |
| `&>`     | Перенапляє вихід та помилки                  |
| `&>>`    | Додає перенапрямлений вихід і помилок        |
| `<`      | Перенапляє вхід                              |
| `<<`     | [Тут документів](http://tldp.org/LDP/abs/html/here-docs.html) синтаксис |
| `<<<`    | [Тут строки](http://www.tldp.org/LDP/abs/html/x17837.html) |

Ось кілька прикладів використання перенаправлення:

```bash
# вивід ls буде записаний в list.txt
ls -l > list.txt

# додає вивід до list.txt
ls -a >> list.txt

# усі помилки буде записано в errors.txt
grep da * 2> errors.txt

# читання з errors.txt
less < errors.txt
```

### Канали

Ми можемо скерувати стандартні потоки не тільки в файли, але й до інших програм. **Канали** дозволяють використовувати результат програми в якості входу іншої.

В прикладі нижче, `command1` відправляє вихід в `command2`, яка потім передає його на вхід `command3`:

    command1 | command2 | command3

Конструкції схожі на цю називають **конвеєрами**.

На практиці це може бути використано для обробки даних за допомогою різних програм. Наприклад, тут результат `ls -l` відправляєть програмі `grep`, яка видає тільки файли з розширенням `.md`, і цей результат в кінці відправляється до `less`:

    ls -l | grep .md$ | less

### Список команд

**Список команд** є послідовностями з одного або декількох конвеєрів, розділених операторами `;`, `&`, `&&` або `||`.

Якщо команда завершується керуючим оператором `&`, оболонка виконує команду асинхронно в підоболонці. Іншими словами, ця команда буде виконується в фоновому режимі.

Команди розділені `;` виконуються послідовно: одна за одною. Оболонка чекає завершення кожної команди.

```bash
# command2 буде виконуватися після command1
command1 ; command2

# який є таким же, як
command1
command2
```

Списки розділені `&&` і `||` називаються _І_ та _АБО_ списками відповідно.

_І-список_ виглядає наступним чином:
```bash
# command2 виконуватиметься лише тоді, якщо command1 завершиться успішно (отримається 0 код виходу)
command1 && command2
```

_ Або-список_ має вигляд:

```bash
# command2 виконуватиметься лише тоді, якщо command1 завершиться не успішно (отримується помилка)
command1 || command2
```

Код повернення _І_ і _АБО_ списків повертає статус виходу останньої виконаної команди.

## ЗАВДАННЯ

Створіть файл з ім'ям `lists.bash`.

Використовуючи списки команд (`&`, `&&`, `||` або `;`) виведіть `First parameter is false.`, якщо перший позиційний параметр `false`. Якщо другий параметр `true`, виведіть шлях до поточної директорії. Якщо третій параметр `true`, виведіть список файлів в поточному каталозі або `Third parameter is false.`, якщо він `false`.

Наприклад:

    ./lists.bash true true false

Результат:

    ~/Projects/bash-exercices.
    Third parameter is false.

---
