Як і в інших мовах, в Bash умовні вирази дозволяють вирішувати які дії нам виконувати, а які ні. Результат визначається шляхом оцінки виразу, який повинний бути вкладений в `[[]]`.

Умовні вирази можуть включати `&&` та `||` оператори, які відповідають _І_ та _АБО_. Окрім них існують ще й [інші корисні вирази](https://github.com/denysdovhan/bash-handbook#primary-and-combining-expressions).

Перш ніж ми почнемо, розглянемо первинні вирази.

### Комбіновані та первинні вирази

Вирази вклаедні всередині `[[ ]]` (чи `[ ]` для `sh`) називаються **тестовими командами** або **первинними**. Ці вирази допомагають нам вказати результат умови. В таблиці нижче, ви використовуємо `[ ]`, тому що це працює для `sh` також. Тут є опис [різниці між подвійними і одинарними квадратними дужками в Bash](http://serverfault.com/a/52050).

**Робота за файловою системою:**

| Вираз         | Зміст                                                        |
| :-----------: | :----------------------------------------------------------- |
| `[ -e FILE ]` | Істина якщо `FILE` існує.                                    |
| `[ -d FILE ]` | Істина якщо `FILE` уснує і є директорією.                    |
| `[ -r FILE ]` | Істина якщо `FILE` уснує і є читабельною.                    |
| `[ -w FILE ]` | Істина якщо `FILE` уснує і є можливість запису.              |
| `[ -x FILE ]` | Істина якщо `FILE` уснує і є виконуваним.                    |
| `[ FILE1 -nt FILE2 ]` | FILE1 є новішим ніж FILE2.                           |
| `[ FILE1 -ot FILE2 ]` | FILE1 є старішим ніж FILE2.                          |

**Робота з рядками:**

| Вираз          | Зміст                                                       |
| :------------: | :---------------------------------------------------------- |
| `[ -z STR ]`   | `STR` є пустим (довжина нульова).                           |
| `[ -n STR ]`   |`STR` не є пустою (довжина не-нульва).                       |
| `[ STR1 == STR2 ]` | `STR1` та `STR2` ідентичні.                             |
| `[ STR1 != STR2 ]` | `STR1` та `STR2` не ідентичні.                          |

**Арифметичні бінарні оператори:**

| Вираз             | Зміст                                                    |
| :-----------------: | :----------------------------------------------------- |
| `[ ARG1 -eq ARG2 ]` | `ARG1` дорівнює `ARG2`.                                |
| `[ ARG1 -ne ARG2 ]` | `ARG1` не дорівнює `ARG2` .                            |
| `[ ARG1 -lt ARG2 ]` | `ARG1` менший ніж `ARG2`.                              |
| `[ ARG1 -le ARG2 ]` | `ARG1` менше або дорівнює `ARG2`.                      |
| `[ ARG1 -gt ARG2 ]` | `ARG1` більше ніж `ARG2`.                              |
| `[ ARG1 -ge ARG2 ]` | `ARG1` більше або дорівнює `ARG2`.                     |

Умови можуть бути кобміновані з допомогою **комбінованих виразів:**

| Операція       | Ефект                                                       |
| :------------: | :---------------------------------------------------------- |
| `[ ! EXPR ]`   | True якщо `EXPR` є False.                                   |
| `[ (EXPR) ]`   | Повертає значення`EXPR`.                                    |
| `[ EXPR1 -a EXPR2 ]` | Логічне _І_. True якщо `EXPR1` та `EXPR2` є істинним. |
| `[ EXPR1 -o EXPR2 ]` | Логічне _АБО_. True якщо `EXPR1` або `EXPR2` є істиним.|

Звичайно, є ще багато інших корисних первинних виразів і ви можете легко знайти їх в [Bash man pages](http://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html)

### Використання `if`

`if` працює точно так, як і в ішних мовах програмування. Якщо вираз всередині дужок є істинним, тоді код між `then` і `fi` буде виконуватися. `fi` показує кінець умовно виконувального коду.

```bash
# Однорядковий
if [[ 1 -eq 1 ]]; then echo "true"; fi

# Багаторядковий
if [[ 1 -eq 1 ]]; then
  echo "true"
fi
```

Точно так само ми можемо використовувати `if..else` вираз:

```bash
# Однорядковий
if [[ 2 -ne 1 ]]; then echo "true"; else echo "false"; fi

# Багаторядковий
if [[ 2 -ne 1 ]]; then
  echo "true"
else
  echo "false"
fi
```

Іноді виразу `if..else` не достатньо, щоб робити те, що задумано. В цьому випадку ми не повинні забувати про існування виразу `if..elif..else`, який може вирішити цю проблему.

Подивіться на приклад нижче:

```bash
if [[ `uname` == "Adam" ]]; then
  echo "Не їж яблуко!"
elif [[ `uname` == "Eva" ]]; then
  echo "Не бери яблуко!"
else
  echo "Яблука прекрасні!"
fi
```

## ЗАВДАННЯ

Створіть файл з `if.bash`.

Використовуючи `if` вираз і первинні вирази, виведіть `Good morning!`, якщо перший позиційний параметр менше 12. Виведіть `Good afternoon!`, якщо воно більше, ніж 12, але менше 18. Інакше виведіть `Good evening!` якщо воно більше 18. Подбайте про випадки, коли позиційний аргумент менше 0 і більше 24 (виведіть `Error!` в цьому випадку).

Для прикладу:

    ./if.bash -5
    ./if.bash 12
    ./if.bash 21

Результат:

    Error!
    Good afternoon!
    Good evening!

---
